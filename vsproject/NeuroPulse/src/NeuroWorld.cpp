#include "NeuroWorld.h"
#include "AdvancedOgreFramework.hpp"
#include <Ogre.h>

#include <ResourceManager.h>

#include <OutputComponent.h>
#include "ConstructConnectionComponent.h"
#include "GraphicComponent.h"

np::NeuroWorld::NeuroWorld( np::NeuroWorldSettings* settings) :
	sceneManager( OgreFramework::getSingletonPtr()->m_pRoot->createSceneManager( Ogre::ST_GENERIC, "NeuroWorldSceneMgr")),
	settings( settings),
	nodes(),
	constructs(),
	constructConnections(),
	systems()
{
	new np::ResourceManager();
	np::ResourceManager* rm = np::ResourceManager::getSingletonPtr();

	rm->registerType( "RawEnergy", "Energy generated by Nodes.", Ogre::ColourValue( 0.0, 0.0, 1.0));
	rm->registerType( "SexyEnergy", "Processed energy that most Constructs require to run.", Ogre::ColourValue( 0.2, 0.2, 1.0));
	rm->registerType( "Instruction", "Instructions can do things...", Ogre::ColourValue( 0.2, 0.8, 2.0));
	rm->registerType( "Heat", "Hot stuff.", Ogre::ColourValue( 1.0, 0.0, 0.0));
	rm->registerType( "HubSchematic", "Hubba Bubba build guild.", Ogre::ColourValue( 0.55, 0.44, 0.28));

	sceneManager->setAmbientLight( Ogre::ColourValue(0.4f, 0.4f, 0.4f));
	sceneManager->setShadowTechnique( Ogre::SHADOWTYPE_STENCIL_ADDITIVE);

	camera = sceneManager->createCamera("NeuroWorldCamera");

	camera->setPosition( Ogre::Vector3( 0.0, 220.0, 0.0));
	camera->lookAt( Ogre::Vector3( 0.0, 0.0, -60.0));

	camera->setNearClipDistance( 5);
	camera->setAspectRatio( Ogre::Real(OgreFramework::getSingletonPtr()->m_pViewport->getActualWidth()) /
		Ogre::Real( OgreFramework::getSingletonPtr()->m_pViewport->getActualHeight()));
	OgreFramework::getSingletonPtr()->m_pViewport->setCamera( camera);

	entityRayQuery = sceneManager->createRayQuery( Ogre::Ray());

	esScene = new ac::es::Scene();
	gameObjectFactory = new np::GameObjectFactory( this);

	eventManager = new np::EventManager();

	/* init systems and shit */
	reactionSystem = new np::ReactionSystem();
	outputSystem = new np::OutputSystem( eventManager, settings);
	animationSystem = new np::AnimationSystem();
	graphicSystem = new np::GraphicSystem( sceneManager);
	connectionDisplaySystem = new np::ConnectionDisplaySystem( sceneManager);
	pulseSystem = new np::PulseSystem( gameObjectFactory, eventManager);
	pulseTransferSystem = new np::PulseTransferSystem();
	heatSystem = new HeatSystem(gameObjectFactory);
	constructConnectionSystem = new np::ConstructConnectionSystem();

	constructSystem = new np::ConstructSystem();
	constructUpgradeSystem = new np::ConstructUpgradeSystem(gameObjectFactory);
	resourceTransferSystem = new np::ResourceTransferSystem();
	hubConstructionSystem = new np::HubConstructionSystem( this);

	addEntitySystem( reactionSystem);
	addEntitySystem( outputSystem);

	addEntitySystem( constructConnectionSystem);
	addEntitySystem( animationSystem);
	addEntitySystem( graphicSystem);
	addEntitySystem( connectionDisplaySystem);

	addEntitySystem( pulseSystem);
	addEntitySystem( pulseTransferSystem);

	addEntitySystem( resourceTransferSystem);

	addEntitySystem( constructSystem);

	addEntitySystem( heatSystem);

	addEntitySystem( hubConstructionSystem);
	addEntitySystem( constructUpgradeSystem);
}

np::NeuroWorld::~NeuroWorld(void)
{
	cleanup();
}

void np::NeuroWorld::cleanup( void )
{
	removeAllEntitySystems();

	delete esScene;

	sceneManager->destroyCamera( camera);
	sceneManager->destroyQuery( entityRayQuery);

	if( sceneManager)
		OgreFramework::getSingletonPtr()->m_pRoot->destroySceneManager( sceneManager);
	
	delete ResourceManager::getSingletonPtr();
}

void np::NeuroWorld::update( double timeSinceLastFrame )
{
	reactionSystem->setDeltaTime( timeSinceLastFrame);
	heatSystem->setDeltaTime(timeSinceLastFrame);
	outputSystem->globalTick( timeSinceLastFrame);
	

	esScene->update();

	eventManager->refresh();
}

Ogre::Entity* np::NeuroWorld::getEntityUnderPoint( float x, float y)
{
	Ogre::Ray mouseRay = camera->getCameraToViewportRay( x, y);
	entityRayQuery->setRay( mouseRay);
	entityRayQuery->setSortByDistance( true);
	entityRayQuery->setQueryMask( NODE_MASK);

	Ogre::RaySceneQueryResult &result = entityRayQuery->execute();
	Ogre::RaySceneQueryResult::iterator itr;

	for(itr = result.begin(); itr != result.end(); itr++)
	{
		if(itr->movable)
		{
			return sceneManager->getEntity( itr->movable->getName());
		}
	}

	return NULL;
}

void np::NeuroWorld::addEntitySystem( ac::es::EntitySystem* system )
{
	esScene->insertEntitySystem( system);
	systems.push_back( system);
}

void np::NeuroWorld::removeAllEntitySystems()
{
	for ( int i = 0; i < systems.size(); i++) esScene->removeEntitySystem( systems[i]);
}

Ogre::Entity* np::NeuroWorld::getNodeUnderPoint( float x, float y )
{
	Ogre::Ray mouseRay = camera->getCameraToViewportRay( x, y);
	entityRayQuery->setRay( mouseRay);
	entityRayQuery->setSortByDistance( true);
	entityRayQuery->setQueryMask( NODE_MASK);

	Ogre::RaySceneQueryResult &result = entityRayQuery->execute();
	Ogre::RaySceneQueryResult::iterator itr;

	for( itr = result.begin(); itr != result.end(); itr++)
	{
		if( itr->movable)
		{
			return sceneManager->getEntity( itr->movable->getName());
		}
	}

	return NULL;
}

Ogre::Entity* np::NeuroWorld::getConstructUnderPoint( float x, float y)
{
	Ogre::Ray mouseRay = camera->getCameraToViewportRay( x, y);
	entityRayQuery->setRay( mouseRay);
	entityRayQuery->setSortByDistance( true);
	entityRayQuery->setQueryMask( CONSTRUCT_MASK);

	Ogre::RaySceneQueryResult &result = entityRayQuery->execute();
	Ogre::RaySceneQueryResult::iterator itr;

	for( itr = result.begin(); itr != result.end(); itr++)
	{
		if( itr->movable)
		{
			Ogre::Entity* entity = sceneManager->getEntity( itr->movable->getName());

			/*Ogre::Plane constructPlane( Ogre::Vector3::UNIT_Y, 13.0);
			std::pair<bool, Ogre::Real> result = mouseRay.intersects( constructPlane);

			if ( result.first)
			{
				Ogre::Vector3 intersectionPoint = mouseRay.getPoint( result.second);
				intersectionPoint = entity->_getParentNodeFullTransform().transformAffine( intersectionPoint);
				
				if ( intersectionPoint.x > -8.0 && intersectionPoint.x < 8.0 && intersectionPoint.y > -8.0 && intersectionPoint.y < 8.0)
				{*/
					return entity;
				/*}
			}*/
		}
	}

	return NULL;
}

Ogre::Entity* np::NeuroWorld::getConstructConnectorUnderPoint( float x, float y)
{
	Ogre::Ray mouseRay = camera->getCameraToViewportRay( x, y);
	entityRayQuery->setRay( mouseRay);
	entityRayQuery->setSortByDistance( true);
	entityRayQuery->setQueryMask( CONSTRUCT_CONNECTOR_MASK);

	Ogre::RaySceneQueryResult &result = entityRayQuery->execute();
	Ogre::RaySceneQueryResult::iterator itr;

	for( itr = result.begin(); itr != result.end(); itr++)
	{
		if( itr->movable)
		{
			Ogre::Entity* entity = sceneManager->getEntity( itr->movable->getName());

			/*Ogre::Plane constructPlane( Ogre::Vector3::UNIT_Y, 13.0);
			std::pair<bool, Ogre::Real> result = mouseRay.intersects( constructPlane);

			if ( result.first)
			{
				Ogre::Vector3 intersectionPoint = mouseRay.getPoint( result.second);
				intersectionPoint = entity->_getParentNodeFullTransform().transformAffine( intersectionPoint);

				if ( intersectionPoint.squaredDistance( entity->getParentSceneNode()->getPosition()) < 2.0 * 2.0)
				{*/
					return entity;
				/*}
			}*/
		}
	}

	return NULL;
}

std::pair<int,double> np::NeuroWorld::getNearestConnectionFromPoint( float x, float y, ac::es::EntityPtr nodeEntity, double maxDistance)
{
	OgreFramework::getSingletonPtr()->m_pLog->logMessage("try conn: ");

	Ogre::Ray mouseRay = camera->getCameraToViewportRay( x, y);
	const Ogre::Vector3& p1 = mouseRay.getOrigin();
	const Ogre::Vector3& p2 = mouseRay.getOrigin() + mouseRay.getDirection();

	np::OutputComponent* output = nodeEntity->getComponent<np::OutputComponent>();
	np::TransformComponent* transform = nodeEntity->getComponent<np::TransformComponent>();

	const Ogre::Vector3& p3 = transform->position;

	double minDistance = maxDistance;
	double minU = 0.0;
	int connection = -1;

	for ( int i = 0; i < output->connections.size(); i++)
	{
		np::ConnectionBase* base = output->connections[i];

		ac::es::EntityPtr e2 = base->target->parent;
		np::TransformComponent* transform2 = e2->getComponent<np::TransformComponent>();

		const Ogre::Vector3& p4 = transform2->position;

		double d1343 =	( p1.x - p3.x) * ( p4.x - p3.x) +
						( p1.y - p3.y) * ( p4.y - p3.y) +
						( p1.z - p3.z) * ( p4.z - p3.z);

		double d4321 =	( p4.x - p3.x) * ( p2.x - p1.x) +
						( p4.y - p3.y) * ( p2.y - p1.y) +
						( p4.z - p3.z) * ( p2.z - p1.z);

		double d1321 =	( p1.x - p3.x) * ( p2.x - p1.x) +
						( p1.y - p3.y) * ( p2.y - p1.y) +
						( p1.z - p3.z) * ( p2.z - p1.z);

		double d4343 =	( p4.x - p3.x) * ( p4.x - p3.x) +
						( p4.y - p3.y) * ( p4.y - p3.y) +
						( p4.z - p3.z) * ( p4.z - p3.z);

		double d2121 =	( p2.x - p1.x) * ( p2.x - p1.x) +
						( p2.y - p1.y) * ( p2.y - p1.y) +
						( p2.z - p1.z) * ( p2.z - p1.z);

		double u1 = ( d1343 * d4321 - d1321 * d4343) / ( d2121 * d4343 - d4321 * d4321);
		double u2 = ( d1343 + u1 * d4321) / d4343;

		Ogre::Vector3 fp1 = mouseRay.getPoint( u1);
		Ogre::Vector3 fp2 = p3 + u2 * ( p4 - p3);

		double dist = fp1.distance( fp2);

		OgreFramework::getSingletonPtr()->m_pLog->logMessage(Ogre::StringConverter::toString( i) + " " + Ogre::StringConverter::toString( (float)dist));

		if ( dist < minDistance && u2 >= 0.0 && u2 <= 0.5)
		{
			minDistance = dist;
			minU = u2;
			connection = i;
		}
	}

	OgreFramework::getSingletonPtr()->m_pLog->logMessage("final: " + Ogre::StringConverter::toString( connection) + " " + Ogre::StringConverter::toString( (float)minDistance));

	return std::pair<int, double>( connection, minU);
}

Ogre::Entity* np::NeuroWorld::getNearestConstructConnectionFromPoint( float x, float y, double maxDistance)
{
	Ogre::Ray mouseRay = camera->getCameraToViewportRay( x, y);
	entityRayQuery->setRay( mouseRay);
	entityRayQuery->setSortByDistance( true);
	entityRayQuery->setQueryMask( CONSTRUCT_CONNECTION_MASK);

	const Ogre::Vector3& p1 = mouseRay.getOrigin();
	const Ogre::Vector3& p2 = mouseRay.getOrigin() + mouseRay.getDirection();

	Ogre::RaySceneQueryResult &result = entityRayQuery->execute();
	Ogre::RaySceneQueryResult::iterator itr;

	double minDistance = maxDistance;
	double minU = 0.0;
	Ogre::Entity* connection = NULL;

	OgreFramework::getSingletonPtr()->m_pLog->logMessage( "Commencing const conn search");
	for( itr = result.begin(); itr != result.end(); itr++)
	{
		if( itr->movable)
		{
			Ogre::Entity* entity = sceneManager->getEntity( itr->movable->getName());
			ac::es::EntityPtr connectionEntity = entity->getUserObjectBindings().getUserAny("Entity").get<ac::es::EntityPtr>();
			np::ConstructConnectionComponent* constructConnection = connectionEntity->getComponent<np::ConstructConnectionComponent>();

			ac::es::EntityPtr e1 = constructConnection->entity1;
			np::TransformComponent* transform1 = e1->getComponent<np::TransformComponent>();
			np::GraphicComponent* graphic1 = e1->getComponent<np::GraphicComponent>();
			ac::es::EntityPtr e2 = constructConnection->entity2;
			np::TransformComponent* transform2 = e2->getComponent<np::TransformComponent>();
			np::GraphicComponent* graphic2 = e2->getComponent<np::GraphicComponent>();

			const Ogre::Vector3& p3 = graphic1->node->_getDerivedPosition();
			const Ogre::Vector3& p4 = graphic2->node->_getDerivedPosition();

			double d1343 =	( p1.x - p3.x) * ( p4.x - p3.x) +
				( p1.y - p3.y) * ( p4.y - p3.y) +
				( p1.z - p3.z) * ( p4.z - p3.z);

			double d4321 =	( p4.x - p3.x) * ( p2.x - p1.x) +
				( p4.y - p3.y) * ( p2.y - p1.y) +
				( p4.z - p3.z) * ( p2.z - p1.z);

			double d1321 =	( p1.x - p3.x) * ( p2.x - p1.x) +
				( p1.y - p3.y) * ( p2.y - p1.y) +
				( p1.z - p3.z) * ( p2.z - p1.z);

			double d4343 =	( p4.x - p3.x) * ( p4.x - p3.x) +
				( p4.y - p3.y) * ( p4.y - p3.y) +
				( p4.z - p3.z) * ( p4.z - p3.z);

			double d2121 =	( p2.x - p1.x) * ( p2.x - p1.x) +
				( p2.y - p1.y) * ( p2.y - p1.y) +
				( p2.z - p1.z) * ( p2.z - p1.z);

			double u1 = ( d1343 * d4321 - d1321 * d4343) / ( d2121 * d4343 - d4321 * d4321);
			double u2 = ( d1343 + u1 * d4321) / d4343;

			Ogre::Vector3 fp1 = mouseRay.getPoint( u1);
			Ogre::Vector3 fp2 = p3 + u2 * ( p4 - p3);

			double dist = fp1.distance( fp2);
			OgreFramework::getSingletonPtr()->m_pLog->logMessage( Ogre::StringConverter::toString( (float)dist));

			if ( dist < minDistance && u2 >= 0.0 && u2 <= 1.0)
			{
				minDistance = dist;
				minU = u2;
				connection = entity;

				OgreFramework::getSingletonPtr()->m_pLog->logMessage( "Found closest const conn.");
			}
		}
	}

	return connection;
}

Ogre::Vector3 np::NeuroWorld::getRayPlane( float x, float y )
{
	Ogre::Ray mouseRay = camera->getCameraToViewportRay( x, y);
	Ogre::Plane plane( Ogre::Vector3::UNIT_Y, 13);

	return mouseRay.getPoint( mouseRay.intersects( plane).second);
}

bool np::NeuroWorld::isValid( ac::es::EntityPtr e1, ac::es::EntityPtr e2 )
{
	if ( isValidInputOutput( e1, e2)) return true;
	else if ( isValidInputOutput( e2, e1)) return true;

	return false;
}

bool np::NeuroWorld::isValidInputOutput( ac::es::EntityPtr inputEntity, ac::es::EntityPtr outputEntity)
{
	np::ResourceInputComponent* input1 = inputEntity->getComponent<np::ResourceInputComponent>();
	np::ResourceOutputComponent* output2 = outputEntity->getComponent<np::ResourceOutputComponent>();
	np::BufferComponent* buffer1 = inputEntity->getComponent<np::BufferComponent>();
	np::BufferComponent* buffer2 = outputEntity->getComponent<np::BufferComponent>();

	if ( input1 != NULL && output2 != NULL && buffer1 != NULL && buffer2 != NULL && buffer1->getTypes().contains( &buffer2->getTypes()))
	{
		return true;
	}

	return false;
}

bool np::NeuroWorld::connect( ac::es::EntityPtr e1, ac::es::EntityPtr e2 )
{
	if ( connectInputOutput( e1, e2)) return true;
	else if ( connectInputOutput( e2, e1)) return true;

	return false;
}

bool np::NeuroWorld::connectInputOutput( ac::es::EntityPtr inputEntity, ac::es::EntityPtr outputEntity)
{
	if ( isValidInputOutput( inputEntity, outputEntity))
	{
		np::ResourceInputComponent* input1 = inputEntity->getComponent<np::ResourceInputComponent>();
		np::ResourceOutputComponent* output2 = outputEntity->getComponent<np::ResourceOutputComponent>();

		np::ConstructConnectionComponent* conn;
		if ( input1->target != NULL)
		{
			conn = input1->connection->getComponent<np::ConstructConnectionComponent>();
			disconnect( conn->entity1, conn->entity2);
		}
		if ( output2->target != NULL)
		{
			conn = output2->connection->getComponent<np::ConstructConnectionComponent>();
			disconnect( conn->entity1, conn->entity2);
		}

		input1->connect( outputEntity);
		output2->connect( inputEntity);

		ac::es::EntityPtr connection = gameObjectFactory->createConstructConnectionEntity( inputEntity, outputEntity);
		input1->connection = connection;
		output2->connection = connection;

		return true;
	}

	return false;
}

bool np::NeuroWorld::disconnect( ac::es::EntityPtr e1, ac::es::EntityPtr e2 )
{
	if ( disconnectInputOutput( e1, e2)) return true;
	else if ( disconnectInputOutput( e2, e1)) return true;

	return false;
}

bool np::NeuroWorld::disconnectInputOutput( ac::es::EntityPtr inputEntity, ac::es::EntityPtr outputEntity)
{
	np::ResourceInputComponent* input1 = inputEntity->getComponent<np::ResourceInputComponent>();
	np::ResourceOutputComponent* output2 = outputEntity->getComponent<np::ResourceOutputComponent>();

	if ( input1 == NULL || output2 == NULL || !isValidInputOutput( inputEntity, outputEntity)) return false;

	np::PulseGateComponent* pulseGate;

	if ( input1->target == outputEntity && output2->target == inputEntity)
	{
		gameObjectFactory->killConstructConnectionEntity( input1->connection);

		input1->disconnect();
		output2->disconnect();

		if ( inputEntity->containsComponent<np::PulseGateComponent>())
		{
			np::PulseGateComponent* pulseGateComponent = inputEntity->getComponent<np::PulseGateComponent>();
			
			np::OutputComponent* output = pulseGateComponent->nodeEntity->getComponent<np::OutputComponent>();
			
			output->connections[ pulseGateComponent->connectionIndex]->removeFeed( inputEntity);
			gameObjectFactory->killPulseGate( inputEntity);
		}
		else if ( outputEntity->containsComponent<np::PulseGateComponent>())
		{
			np::PulseGateComponent* pulseGateComponent = outputEntity->getComponent<np::PulseGateComponent>();

			np::OutputComponent* output = pulseGateComponent->nodeEntity->getComponent<np::OutputComponent>();
			
			output->connections[ pulseGateComponent->connectionIndex]->removeFeed( outputEntity);
			gameObjectFactory->killPulseGate( outputEntity);
		}

		return true;
	}

	return false;
}

void np::NeuroWorld::movePulseGate( ac::es::EntityPtr pulseGate, int connection )
{

}
